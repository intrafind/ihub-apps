# OAuth 2.0 Authorization Code Flow -- Implementation Task Breakdown

**Date:** 2026-02-25
**Related PRD:** `/concepts/2026-02-24 OAuth Authorization Code Flow PRD.md`
**Status:** Ready for Implementation
**Author:** Generated by Claude (Tech Lead / Product Manager role)

---

## Purpose

This document breaks the OAuth 2.0 Authorization Code Flow PRD (PRD-2026-OAUTH-001) into 12 independent, parallelizable implementation tasks. Each task can be assigned to a separate developer or subagent. The document includes dependency graphs, parallel execution plans, risk assessment, and MVP prioritization.

---

## Dependency Graph

```
                        +-------------------+
                        | TASK 1: Migration |
                        | & Schema Extension|
                        +---------+---------+
                                  |
                 +----------------+----------------+
                 |                |                 |
        +--------v-------+ +-----v--------+ +------v--------+
        | TASK 2: AuthZ  | | TASK 3: Token| | TASK 4: Admin |
        | Code Store +   | | Endpoint Ext | | UI Extension  |
        | PKCE Utilities | | + id_token   | |               |
        +--------+-------+ +-----+--------+ +------+--------+
                 |                |                  |
                 +--------+-------+                  |
                          |                          |
                 +--------v--------+                 |
                 | TASK 5: Authorize|                 |
                 | Endpoint +      |<----------------+
                 | Consent Screen  |
                 +--------+--------+
                          |
              +-----------+-----------+
              |                       |
     +--------v--------+    +--------v--------+
     | TASK 6: Refresh  |    | TASK 7: UserInfo|
     | Tokens +         |    | + Revocation    |
     | Rotation         |    |                 |
     +--------+---------+    +--------+--------+
              |                       |
              +-----------+-----------+
                          |
                 +--------v--------+
                 | TASK 8: JWT Auth|
                 | Middleware Ext  |
                 +--------+--------+
                          |
              +-----------+-----------+
              |                       |
     +--------v--------+    +--------v--------+
     | TASK 9: Well-   |    | TASK 10: Session|
     | Known Updates   |    | Middleware      |
     +--------+--------+    +--------+--------+
              |                       |
              +-----------+-----------+
                          |
                 +--------v--------+
                 | TASK 11: Example|
                 | Client App     |
                 +--------+--------+
                          |
                 +--------v--------+
                 | TASK 12: E2E   |
                 | Testing +      |
                 | Verification   |
                 +-----------------+
```

---

## Parallel Execution Plan

### Wave 1 -- Foundation (No dependencies, start immediately)

| Task | Description | Complexity | Est. Effort |
|------|-------------|------------|-------------|
| TASK 1 | Migration and Schema Extension | M | 0.5 day |
| TASK 2 | Authorization Code Store + PKCE Utilities | M | 1 day |
| TASK 3 | Token Endpoint Extension + id_token generation | L | 1.5 days |
| TASK 4 | Admin UI Extension | L | 2 days |

### Wave 2 -- Core Flow (Depends on Wave 1)

| Task | Description | Depends On | Complexity | Est. Effort |
|------|-------------|------------|------------|-------------|
| TASK 5 | Authorize Endpoint + Consent Screen | 1, 2 | XL | 3 days |

### Wave 3 -- Supporting Features (Depends on Wave 2)

| Task | Description | Depends On | Complexity | Est. Effort |
|------|-------------|------------|------------|-------------|
| TASK 6 | Refresh Tokens + Rotation | 1, 3 | L | 1.5 days |
| TASK 7 | UserInfo Endpoint + Token Revocation | 3 | M | 1 day |

### Wave 4 -- Integration (Depends on Waves 1-3)

| Task | Description | Depends On | Complexity | Est. Effort |
|------|-------------|------------|------------|-------------|
| TASK 8 | JWT Auth Middleware Extension | 1, 3 | M | 1 day |
| TASK 9 | Well-Known / OIDC Discovery Updates | 3, 7 | S | 0.5 day |
| TASK 10 | Session Middleware for OAuth Flow | 5 | S | 0.5 day |

### Wave 5 -- Validation (Depends on everything)

| Task | Description | Depends On | Complexity | Est. Effort |
|------|-------------|------------|------------|-------------|
| TASK 11 | Example Client Application | 5, 6, 7 | L | 2 days |
| TASK 12 | End-to-End Testing + Security Verification | All | XL | 3 days |

---

## MVP vs. Nice-to-Have

### MVP (Minimum for a working Authorization Code Flow)

- **TASK 1:** Migration and Schema (required foundation)
- **TASK 2:** Auth Code Store + PKCE (core mechanic)
- **TASK 3:** Token Endpoint Extension (core mechanic)
- **TASK 5:** Authorize Endpoint + Consent Screen (core UI)
- **TASK 8:** JWT Auth Middleware Extension (tokens must be usable)
- **TASK 9:** Well-Known Updates (discovery must be accurate)
- **TASK 10:** Session Middleware (flow needs sessions)

### Nice-to-Have (Important but can follow MVP)

- **TASK 4:** Admin UI Extension (clients can be manually edited in JSON initially)
- **TASK 6:** Refresh Tokens (access tokens work without refresh)
- **TASK 7:** UserInfo + Revocation (not strictly needed for basic flow)
- **TASK 11:** Example Client App (documentation/demo)
- **TASK 12:** Full E2E Testing (manual testing can validate MVP)

---

## TASK 1: Migration and Client Schema Extension

### Scope

Add new fields to the OAuth client model and create a migration script that upgrades existing client configurations. Create empty storage files for refresh tokens and consent.

### Complexity: M (Medium)

### Files to CREATE

- `server/migrations/V007__add_oauth_authorization_code_support.js`
- `server/defaults/config/oauth-refresh-tokens.json` (default empty file)
- `server/defaults/config/oauth-consent.json` (default empty file)

### Files to MODIFY

- `server/utils/oauthClientManager.js` -- Add new fields to `createOAuthClient()` and `updateOAuthClient()` allowed updates list

### Deliverables

1. **Migration script V007** that:
   - Adds `oauth.authorizationCodeLifetimeSeconds: 600` to `platform.json`
   - Adds `oauth.refreshTokenLifetimeDays: 30` to `platform.json`
   - Adds `oauth.refreshTokenRotation: true` to `platform.json`
   - Adds `oauth.requirePkceForPublicClients: true` to `platform.json`
   - Adds `oauth.consentRememberDays: 30` to `platform.json`
   - Adds `oauth.idTokenEnabled: true` to `platform.json`
   - Adds `oauth.allowedResponseTypes: ["code"]` to `platform.json`
   - For each existing client in `oauth-clients.json`:
     - Adds `clientType: "confidential"` (default)
     - Adds `grantTypes: ["client_credentials"]` (preserve existing behavior)
     - Adds `redirectUris: []`
     - Adds `postLogoutRedirectUris: []`
     - Adds `trusted: false`
     - Adds `consentRequired: true`
     - Adds `scopes: ["openid", "profile", "email"]` (if scopes is empty)
   - Creates `oauth-refresh-tokens.json` if missing
   - Creates `oauth-consent.json` if missing

2. **Update `oauthClientManager.js`**:
   - Add `clientType`, `grantTypes`, `redirectUris`, `postLogoutRedirectUris`, `trusted`, `consentRequired` to `allowedUpdates` array in `updateOAuthClient()`
   - Add these fields with defaults in `createOAuthClient()`

### Acceptance Criteria

- [ ] Migration runs without error on a fresh install
- [ ] Migration runs without error on an existing install with clients
- [ ] Existing clients get `grantTypes: ["client_credentials"]` (not authorization_code)
- [ ] New clients can be created with the new fields
- [ ] `updateOAuthClient` accepts and persists the new fields
- [ ] Migration is idempotent (running twice produces same result)
- [ ] Default files are created in `server/defaults/`

### Implementation Notes for Junior Developers

- Follow existing migration patterns. Look at `server/migrations/V006__add_ihub_official_registry.js` for reference.
- Use `ctx.setDefault()` to avoid overwriting admin-set values.
- Use `ctx.transformWhere()` for updating existing clients -- it iterates all items and applies a transform function.
- The migration number is V007 (next available after V006).
- Test by running `node server/server.js` and checking that `contents/config/platform.json` has the new fields.

---

## TASK 2: Authorization Code Store + PKCE Utilities

### Scope

Create an in-memory authorization code store with TTL and single-use enforcement. Create PKCE utility functions for challenge/verifier validation.

### Complexity: M (Medium)

### Files to CREATE

- `server/utils/oauthAuthorizationCodeStore.js`
- `server/utils/pkce.js`

### Deliverables

1. **Authorization Code Store** (`oauthAuthorizationCodeStore.js`):
   - In-memory `Map` with automatic expiration cleanup
   - `generateCode()` -- creates 32-byte hex random code using `crypto.randomBytes(32).toString('hex')`
   - `storeCode(code, data)` -- stores code with metadata:
     ```javascript
     {
       code,
       clientId,
       userId,
       user,           // full user object for token generation
       redirectUri,
       scope,
       codeChallenge,
       codeChallengeMethod,
       nonce,
       createdAt,      // Date.now()
       expiresAt,      // Date.now() + ttlMs
       used: false
     }
     ```
   - `consumeCode(code)` -- returns data and marks code as used (single-use enforcement). Returns null if already used or expired.
   - `revokeCodesByClient(clientId)` -- revokes all codes for a client
   - Periodic cleanup every 60 seconds removes expired codes
   - Default TTL: 10 minutes (600,000 ms), configurable

2. **PKCE Utilities** (`pkce.js`):
   - `generateCodeVerifier()` -- generates 43-128 char verifier using charset `[A-Z][a-z][0-9]-._~`
   - `generateCodeChallenge(verifier)` -- SHA-256 hash, base64url encoded
   - `verifyCodeChallenge(verifier, challenge, method)` -- validates PKCE. Returns boolean.
   - `validateCodeVerifierFormat(verifier)` -- validates format (43-128 chars, allowed charset). Returns boolean.
   - Only supports `S256` method (returns false for `plain`)

### Acceptance Criteria

- [ ] Code generation produces 64-character hex strings (32 bytes)
- [ ] Codes expire after configurable TTL (default 10 minutes)
- [ ] Consuming a code returns the data and marks it as used
- [ ] Attempting to consume a used code returns null
- [ ] Attempting to consume an expired code returns null
- [ ] PKCE verifier validation accepts valid format, rejects invalid
- [ ] PKCE challenge verification works correctly with S256
- [ ] `plain` method is explicitly rejected
- [ ] Cleanup interval removes expired codes from memory
- [ ] Code reuse detection: if a code is consumed twice, a security warning is logged

### Implementation Notes for Junior Developers

- Use `crypto.randomBytes(32).toString('hex')` for code generation (import `crypto` from `'crypto'`).
- For PKCE S256: `crypto.createHash('sha256').update(verifier).digest('base64url')` (Node.js 16+ supports `base64url` encoding directly).
- If `base64url` is not available, do base64 then replace `+` with `-`, `/` with `_`, and remove trailing `=`.
- The store is a simple `Map<string, object>`. Use `setInterval()` for periodic cleanup.
- Export the store as a singleton (module-level instance).

---

## TASK 3: Token Endpoint Extension + id_token Generation

### Scope

Extend the existing `/api/oauth/token` endpoint to support `grant_type=authorization_code`. Create id_token generation when `openid` scope is requested.

### Complexity: L (Large)

### Files to MODIFY

- `server/routes/oauth.js` -- Add authorization_code grant type handling
- `server/utils/oauthTokenService.js` -- Add `generateAuthorizationCodeToken()`, `generateIdToken()`

### Dependencies

- TASK 2 (authorization code store, PKCE utilities)

### Deliverables

1. **Token Endpoint Extension** (in `oauth.js`):
   - Parse `grant_type=authorization_code` alongside existing `client_credentials`
   - For `authorization_code`:
     - Validate `code`, `redirect_uri`, `client_id`
     - For confidential clients: validate `client_secret`
     - For public clients with PKCE: validate `code_verifier` against stored `code_challenge`
     - Consume the authorization code (single-use) via the code store
     - Verify `redirect_uri` matches the one used in the authorization request
     - Verify `client_id` matches the code's client
     - Generate access_token with USER identity (not machine identity)
     - Generate id_token if `openid` scope was requested
     - Return response per RFC 6749

2. **Authorization Code Token Generator** (in `oauthTokenService.js`):
   - `generateAuthorizationCodeToken(client, user, options)`:
     - Creates JWT with user identity: `sub` = user.id (not client.id)
     - Includes `authMode: 'oauth_authorization_code'`
     - Includes `client_id` in claims (for downstream permission checks)
     - Includes user's groups
     - Uses `getJwtSigningKey()` and `getJwtAlgorithm()` from `tokenService.js`
     - Expiration: from client's `tokenExpirationMinutes`

3. **id_token Generator** (in `oauthTokenService.js`):
   - `generateIdToken(user, client, options)`:
     - Standard OIDC claims: `iss: 'ihub-apps'`, `sub: user.id`, `aud: client.clientId`, `exp`, `iat`, `auth_time`
     - Profile claims when `profile` scope: `name`
     - Email claims when `email` scope: `email`
     - Custom claims: `groups`
     - `nonce` from authorization request (for replay protection)
     - **Important:** `aud` = client_id (NOT `ihub-apps` like access tokens)
     - Signed with `getJwtSigningKey()` and `getJwtAlgorithm()`

4. **Token Response Format**:
   ```json
   {
     "access_token": "eyJ...",
     "token_type": "Bearer",
     "expires_in": 3600,
     "scope": "openid profile email",
     "id_token": "eyJ..."
   }
   ```
   Note: `refresh_token` will be added by TASK 6.

### Acceptance Criteria

- [ ] `grant_type=authorization_code` accepted and processed
- [ ] `grant_type=client_credentials` still works unchanged (backward compatibility)
- [ ] Invalid/expired/used authorization code returns `{ "error": "invalid_grant" }`
- [ ] PKCE verification works for public clients
- [ ] Confidential client secret verification works
- [ ] Redirect URI mismatch returns `{ "error": "invalid_grant" }`
- [ ] Client ID mismatch returns `{ "error": "invalid_grant" }`
- [ ] Access token contains user identity (`sub` = user ID)
- [ ] Access token contains `authMode: 'oauth_authorization_code'`
- [ ] Access token contains `client_id` claim
- [ ] id_token generated when `openid` scope present
- [ ] id_token `aud` = client_id
- [ ] id_token includes `nonce` when provided
- [ ] Error responses follow RFC 6749 format
- [ ] Endpoint supports `application/x-www-form-urlencoded` content type

### Implementation Notes for Junior Developers

- **Critical:** The token endpoint MUST support `application/x-www-form-urlencoded` in addition to JSON. Standard OAuth clients send form-encoded bodies. Express already parses this via `express.urlencoded()` in the setup middleware, so `req.body` will contain the parsed fields regardless of content type.
- When generating user-scoped tokens, use `getJwtSigningKey()` and `getJwtAlgorithm()` from `server/utils/tokenService.js`. Do NOT use the hardcoded `HS256` used by `generateOAuthToken()`.
- The existing `generateOAuthToken()` in `oauthTokenService.js` uses hardcoded HS256. Do NOT change it -- that would break existing client_credentials tokens.
- Look at how `generateJwt()` in `tokenService.js` works for reference on RS256 signing.

---

## TASK 4: Admin UI Extension

### Scope

Extend the OAuth client edit and list pages with new fields for client type, grant types, redirect URIs, trust/consent settings.

### Complexity: L (Large)

### Files to MODIFY

- `client/src/features/admin/pages/AdminOAuthClientEditPage.jsx`
- `client/src/features/admin/pages/AdminOAuthClientsPage.jsx`
- `server/routes/admin/oauthClients.js` -- Accept and return new fields

### Dependencies

- TASK 1 (schema must exist for fields to be persisted)

### Deliverables

1. **Client Edit Form -- New Sections** (`AdminOAuthClientEditPage.jsx`):

   a. **Client Type Section** (after Basic Information):
      - Select dropdown: "Confidential (Server-side)" / "Public (SPA/Native)"
      - Default: Confidential
      - When Public selected: show info banner about PKCE, hide secret operations

   b. **Grant Types Section** (after Client Type):
      - Checkbox group: "Client Credentials" / "Authorization Code" / "Refresh Token"
      - Default: Client Credentials checked
      - When "Authorization Code" checked: show Redirect URIs section

   c. **Redirect URIs Section** (conditionally visible):
      - Text input + "Add" button
      - Each URI as a removable tag/badge
      - Validation: valid URL, HTTPS required (except localhost/127.0.0.1)
      - Minimum one required when Authorization Code is enabled

   d. **Post-Logout Redirect URIs Section** (optional):
      - Same UI pattern as Redirect URIs

   e. **Trust and Consent Section**:
      - "Trusted (First-party)" toggle -- default Off
      - "Require Consent" toggle -- default On

   f. **Scopes Section**:
      - Checkboxes: openid, profile, email
      - Default: all checked

2. **Client List Page Updates** (`AdminOAuthClientsPage.jsx`):
   - Client Type badge: "Confidential" (blue) or "Public" (orange)
   - Grant Types column: comma-separated list
   - Redirect URIs count (e.g., "2 URIs")
   - Hide "Rotate Secret" and "Generate Token" buttons for Public clients

3. **Form Data State Extension**:
   ```javascript
   const [formData, setFormData] = useState({
     name: '',
     description: '',
     clientType: 'confidential',
     grantTypes: ['client_credentials'],
     redirectUris: [],
     postLogoutRedirectUris: [],
     trusted: false,
     consentRequired: true,
     scopes: ['openid', 'profile', 'email'],
     allowedApps: [],
     allowedModels: [],
     tokenExpirationMinutes: 60,
     active: true
   });
   ```

4. **Admin Backend Updates** (`server/routes/admin/oauthClients.js`):
   - Accept new fields in POST (create) and PUT (update)
   - Return new fields in GET responses
   - Validate redirect URIs format on server side

### Acceptance Criteria

- [ ] Client Type dropdown renders with two options
- [ ] Public client selection hides secret-related UI elements
- [ ] Grant Types checkboxes render and persist correctly
- [ ] Redirect URIs section shows/hides based on Authorization Code grant
- [ ] URIs can be added and removed dynamically
- [ ] URI validation enforces HTTPS (allows localhost exception)
- [ ] At least one URI required when Authorization Code is enabled (validated on submit)
- [ ] Trust toggle works and persists
- [ ] Consent toggle works and persists
- [ ] Scopes checkboxes work and persist
- [ ] Client list shows new badge columns
- [ ] Existing clients load correctly (missing new fields use defaults)
- [ ] Form submission sends all new fields to backend
- [ ] Backend accepts and persists new fields

### Implementation Notes for Junior Developers

- Follow existing patterns in `AdminOAuthClientEditPage.jsx`. The form already uses `formData` state and `handleInputChange`.
- For the redirect URIs input, you can build a simple component: a text input, an "Add" button, and a list of removable tags. Similar to how `ResourceSelector` works but simpler.
- Handle backward compatibility: when loading an existing client that does not have the new fields, use defaults in the form state (e.g., `clientType: data.client.clientType || 'confidential'`).
- For conditional visibility, use `{formData.grantTypes.includes('authorization_code') && (...)}`
- In the backend (`oauthClients.js`), the `updateOAuthClient` function in `oauthClientManager.js` has an `allowedUpdates` array -- TASK 1 adds the new fields to it. The admin route just needs to pass them through.

---

## TASK 5: Authorization Endpoint + Consent Screen

### Scope

Implement `GET /api/oauth/authorize` (the authorization endpoint) and `POST /api/oauth/authorize/decision` (consent decision). Render a server-side consent HTML page. Handle the full flow: parameter validation, authentication check, consent check, code generation.

### Complexity: XL (Extra Large) -- This is the most complex task

### Files to CREATE

- `server/routes/oauthAuthorize.js` -- Authorization endpoint and consent decision
- `server/utils/oauthConsentManager.js` -- Consent storage and lookup
- `server/utils/csrfProtection.js` -- CSRF token generation and validation
- `server/views/consent.js` -- Server-rendered HTML consent page (template function)

### Files to MODIFY

- `server/server.js` -- Register new routes

### Dependencies

- TASK 1 (client schema with redirectUris, trusted, grantTypes)
- TASK 2 (authorization code store, PKCE validation)

### Deliverables

1. **Authorization Endpoint** (`GET /api/oauth/authorize`):

   **Parameter validation:**
   - `response_type` must be `"code"`
   - `client_id` must match a registered, active client
   - `redirect_uri` must exactly match a registered URI for the client
   - `code_challenge_method` must be `"S256"` when `code_challenge` is present
   - `scope` defaults to `"openid profile email"` if not provided
   - `state` passed through unchanged
   - `nonce` stored for id_token

   **Authentication check:**
   - If user not authenticated: redirect to iHub login page
   - Construct returnUrl: `/api/oauth/authorize?` + all original OAuth params
   - The login page redirects back after authentication

   **Grant type check:**
   - Verify client has `"authorization_code"` in `grantTypes` array

   **PKCE check:**
   - If client is public (`clientType: "public"`): `code_challenge` is REQUIRED
   - If client is confidential: `code_challenge` is recommended but not required

   **Consent check:**
   - If client is `trusted: true`: skip consent, generate code immediately
   - If consent was previously granted and not expired: skip consent
   - Otherwise: render consent screen

   **Code generation:**
   - Generate authorization code via TASK 2's store
   - Redirect to `redirect_uri?code={code}&state={state}`

   **Error handling:**
   - If `redirect_uri` is invalid or missing: show error page (do NOT redirect to unknown URI)
   - If `client_id` unknown: show error page
   - For other errors: redirect to `redirect_uri?error={error_code}&state={state}&error_description={msg}`

2. **Consent Decision Endpoint** (`POST /api/oauth/authorize/decision`):
   - Validate CSRF token
   - If approved: generate code, optionally remember consent, redirect with code
   - If denied: redirect with `error=access_denied`
   - POST body contains: `csrf_token`, `decision` (approve/deny), `remember` (boolean), and all original OAuth params as hidden fields

3. **Consent Screen** (`server/views/consent.js`):
   - Server-rendered HTML using template literals (no template engine)
   - Displays:
     - Application name and description (from client config)
     - Authenticated user's name and email
     - Requested scopes in human-readable form:
       - `openid` -> "Verify your identity"
       - `profile` -> "View your profile information (name)"
       - `email` -> "View your email address"
     - "Approve" and "Deny" buttons
     - "Remember this decision" checkbox
     - Hidden fields: all OAuth params + CSRF token
   - Styled with inline CSS (clean, professional appearance)
   - Responsive design
   - iHub Apps branding (uses the iHub logo/name)

4. **Consent Manager** (`oauthConsentManager.js`):
   - `hasValidConsent(clientId, userId, scopes)` -- checks `oauth-consent.json` for unexpired consent covering the requested scopes
   - `grantConsent(clientId, userId, scopes, ttlDays)` -- stores consent record
   - `revokeConsent(clientId, userId)` -- removes consent record
   - Storage file: `contents/config/oauth-consent.json`
   - Format:
     ```json
     {
       "consents": {
         "client_myapp:user123": {
           "clientId": "client_myapp",
           "userId": "user123",
           "scopes": ["openid", "profile", "email"],
           "grantedAt": "2026-02-25T10:00:00Z",
           "expiresAt": "2026-03-27T10:00:00Z"
         }
       }
     }
     ```

5. **CSRF Protection** (`csrfProtection.js`):
   - `generateCsrfToken(secret, payload)` -- HMAC-SHA256 based token with timestamp
   - `validateCsrfToken(token, secret, payload, maxAgeMs)` -- validates token and expiry
   - Uses the JWT secret as HMAC key
   - Tokens valid for 15 minutes by default

### Acceptance Criteria

- [ ] Valid authorization request with authenticated user shows consent screen
- [ ] Valid authorization request with unauthenticated user redirects to login
- [ ] After login, user returns to authorization endpoint and flow continues
- [ ] Trusted client skips consent screen entirely
- [ ] Previously consented client (within TTL) skips consent screen
- [ ] Approving consent generates code and redirects to redirect_uri with `code` and `state`
- [ ] Denying consent redirects to redirect_uri with `error=access_denied` and `state`
- [ ] "Remember consent" checkbox stores consent for configured TTL
- [ ] Invalid redirect_uri shows error page (does NOT redirect to attacker-controlled URI)
- [ ] Invalid/unknown client_id shows error page
- [ ] Missing required PKCE for public client returns error
- [ ] CSRF token validated on consent decision
- [ ] `state` parameter passed through unchanged in all scenarios
- [ ] Error responses include `error_description`
- [ ] Consent screen renders correctly in Chrome, Firefox, Safari, Edge

### Implementation Notes for Junior Developers

- **No template engine needed.** Create a function in `server/views/consent.js` that takes parameters (clientName, userName, scopes, etc.) and returns an HTML string using JavaScript template literals.
- **Authentication check:** Check `req.user` from the JWT/session middleware. If `!req.user || req.user.id === 'anonymous'`, the user is not authenticated. Construct the returnUrl and redirect.
- **Return URL:** When redirecting to login, the returnUrl should be the full `/api/oauth/authorize` URL with all query parameters so the user comes back after login. URL-encode the whole authorize URL.
- **Stateless consent approach:** Instead of relying on sessions to maintain state between the authorize GET and the decision POST, embed all OAuth parameters as hidden form fields in the consent HTML form. The CSRF token prevents tampering.
- **Error page:** When redirect_uri is invalid, you MUST NOT redirect. Instead, return an HTML error page directly. This prevents open redirect attacks.
- **Register routes** in `server/server.js` by importing and calling the new route registration function. Follow the pattern of `registerOAuthRoutes(app)`.

---

## TASK 6: Refresh Token Support + Rotation

### Scope

Implement refresh token issuance, storage, validation, and rotation. Add `grant_type=refresh_token` to the token endpoint.

### Complexity: L (Large)

### Files to CREATE

- `server/utils/oauthRefreshTokenManager.js`

### Files to MODIFY

- `server/routes/oauth.js` -- Add `grant_type=refresh_token` handling
- `server/utils/oauthTokenService.js` -- Include refresh token in authorization_code response

### Dependencies

- TASK 1 (platform.json config for refresh token settings)
- TASK 3 (token endpoint must support authorization_code)

### Deliverables

1. **Refresh Token Manager** (`oauthRefreshTokenManager.js`):
   - `generateRefreshToken()` -- `'rt_' + crypto.randomBytes(64).toString('hex')` (prefix for easy identification)
   - `storeRefreshToken(token, metadata)` -- bcrypt hash the token, store to `contents/config/oauth-refresh-tokens.json`
     - Metadata: `{ tokenHash, clientId, userId, scopes, issuedAt, expiresAt, revoked: false }`
   - `validateRefreshToken(token, clientId)` -- iterate stored tokens for matching clientId, bcrypt compare each hash
   - `rotateRefreshToken(oldTokenId, clientId)` -- revoke old token, issue and store new one
   - `revokeRefreshToken(tokenId)` -- set `revoked: true`
   - `revokeAllClientTokens(clientId)` -- revoke all tokens for a client
   - `revokeAllUserTokens(userId)` -- revoke all tokens for a user
   - `cleanupExpiredTokens()` -- remove expired and revoked tokens older than 7 days
   - Run cleanup on module load and every 24 hours

2. **Token Endpoint Extension** (in `oauth.js`):
   - Add `grant_type=refresh_token` case:
     - Validate `refresh_token`, `client_id` required
     - For confidential clients: validate `client_secret`
     - Validate refresh token (not expired, not revoked, belongs to client)
     - Issue new access_token with same user identity
     - If `oauth.refreshTokenRotation` is true: issue new refresh_token, revoke old one
     - If `scope` is provided: must be equal to or subset of originally granted scopes
     - Optionally re-issue id_token if `openid` was in original scopes

3. **Update authorization_code token response** (in `oauthTokenService.js` or `oauth.js`):
   - When authorization_code is exchanged: generate refresh_token, store it, include in response
   - Only if client's `grantTypes` includes `"refresh_token"`

### Acceptance Criteria

- [ ] Refresh token generated and included in authorization_code token response
- [ ] `grant_type=refresh_token` issues new access_token
- [ ] Refresh token rotation: old token revoked, new token issued
- [ ] Using a revoked refresh token returns `{ "error": "invalid_grant" }`
- [ ] Using an expired refresh token returns `{ "error": "invalid_grant" }`
- [ ] Scope downscoping works (subset of original scopes accepted)
- [ ] Confidential client secret validated on refresh
- [ ] Public client refresh works without secret (PKCE was already verified at code exchange)
- [ ] Refresh tokens stored as bcrypt hashes (not plaintext)
- [ ] Cleanup removes expired/revoked tokens from storage file
- [ ] Existing client_credentials flow unaffected (no refresh tokens issued)

### Implementation Notes for Junior Developers

- Use `bcryptjs` (already a dependency) for hashing. `bcrypt.hash(token, 10)` and `bcrypt.compare(token, hash)`.
- Bcrypt comparison is slow by design (security feature). For each refresh request, you need to find the right token by comparing against all stored hashes for that clientId. This is O(n) per client. Acceptable for small-to-medium installations.
- Use `atomicWriteJSON` from `server/utils/atomicWrite.js` for safe file writes.
- The `rt_` prefix on refresh tokens helps distinguish them from access tokens and authorization codes.
- Storage file format:
  ```json
  {
    "tokens": {
      "token_id_1": {
        "id": "token_id_1",
        "tokenHash": "$2a$10$...",
        "clientId": "client_myapp_abc123",
        "userId": "user123",
        "scopes": ["openid", "profile", "email"],
        "issuedAt": "2026-02-25T10:00:00Z",
        "expiresAt": "2026-03-27T10:00:00Z",
        "revoked": false
      }
    }
  }
  ```

---

## TASK 7: UserInfo Endpoint + Token Revocation

### Scope

Implement the OIDC UserInfo endpoint and RFC 7009 Token Revocation endpoint.

### Complexity: M (Medium)

### Files to MODIFY

- `server/routes/oauth.js` -- Add `/api/oauth/userinfo` and `/api/oauth/revoke` endpoints

### Dependencies

- TASK 3 (token verification needed)

### Deliverables

1. **UserInfo Endpoint** (`GET /api/oauth/userinfo`):
   - Requires Bearer access_token (from `Authorization` header)
   - Verify token is valid and not expired using `verifyJwt()` from `tokenService.js`
   - Return OIDC standard claims based on granted scopes:
     - Always: `sub` (user ID)
     - With `profile` scope: `name`, `groups`
     - With `email` scope: `email`
   - Also include `permissions` object (resolved at runtime)
   - Reject client_credentials tokens (they have no user identity)
   - Response: `Content-Type: application/json`

2. **Token Revocation Endpoint** (`POST /api/oauth/revoke`):
   - Parameters: `token` (required), `token_type_hint` (optional), `client_id` (required)
   - If `token_type_hint` is `"refresh_token"`: revoke refresh token via refresh token manager
   - If `token_type_hint` is `"access_token"`: acknowledge (JWTs cannot be server-side revoked without a blocklist)
   - If no hint: try refresh token first, then acknowledge
   - **Always return 200 OK** (per RFC 7009 Section 2.2, even for invalid/unknown tokens)
   - For confidential clients: validate `client_id` + `client_secret`

### Acceptance Criteria

- [ ] UserInfo returns correct claims for an authenticated user with authorization_code token
- [ ] UserInfo returns 401 for invalid/missing token
- [ ] UserInfo returns 401 for expired token
- [ ] UserInfo rejects client_credentials tokens (no user context)
- [ ] UserInfo only returns claims matching the token's granted scopes
- [ ] Revocation endpoint accepts refresh tokens and revokes them
- [ ] Revocation returns 200 OK even for invalid/unknown tokens (RFC 7009)
- [ ] Revocation validates client authentication for confidential clients

### Implementation Notes for Junior Developers

- For UserInfo: verify the token using `verifyJwt()` from `tokenService.js`. The decoded payload contains `sub`, `name`, `email`, `groups`, `scopes`, `authMode`.
- Check `authMode` -- only `oauth_authorization_code` tokens have user identity. Reject `oauth_client_credentials` and `oauth_static_api_key` with 401.
- For revocation: the RFC 7009 spec says the server MUST respond with 200 even if the token is invalid. This prevents token enumeration attacks.
- Import `revokeRefreshToken` from the refresh token manager (TASK 6). If TASK 6 is not yet complete, implement the revocation endpoint with a TODO for the actual revocation logic.

---

## TASK 8: JWT Auth Middleware Extension

### Scope

Extend the existing JWT authentication middleware to recognize and handle `authMode: 'oauth_authorization_code'` tokens.

### Complexity: M (Medium)

### Files to MODIFY

- `server/middleware/jwtAuth.js` -- Add handler for `oauth_authorization_code` authMode

### Dependencies

- TASK 1 (client schema with grantTypes)
- TASK 3 (token format for authorization_code tokens)

### Deliverables

1. **New authMode handler** in `jwtAuth.js`:
   - When `decoded.authMode === 'oauth_authorization_code'`:
     - Validate OAuth is enabled
     - Validate the client (`decoded.client_id`) still exists and is active
     - Validate `"authorization_code"` is in the client's `grantTypes`
     - Look up the user from `decoded.sub` -- validate user still exists and is active
     - Check token was not issued before last secret rotation
     - Construct `req.user`:
       ```javascript
       user = {
         id: decoded.sub,
         username: decoded.name || decoded.sub,
         name: decoded.name,
         email: decoded.email,
         groups: decoded.groups || [],
         authMode: 'oauth_authorization_code',
         isOAuthClient: true,
         oauthClientId: decoded.client_id,
         scopes: decoded.scopes || [],
         allowedApps: client.allowedApps || [],    // from client config
         allowedModels: client.allowedModels || [], // from client config
         timestamp: Date.now()
       };
       ```

2. **Permission intersection** (in the enhanceUserWithPermissions middleware or here):
   - User permissions come from group membership
   - Client restrictions come from `allowedApps` / `allowedModels` in client config
   - Final effective permissions = intersection of user and client permissions
   - If client has `["*"]` for apps/models: user permissions apply fully
   - If user has `["*"]` and client has specific restrictions: client restrictions apply

### Acceptance Criteria

- [ ] Authorization code tokens are recognized by `authMode` claim
- [ ] User identity extracted from token (`sub` = user ID, not client ID)
- [ ] Client existence and active status validated at runtime
- [ ] User existence and active status validated at runtime
- [ ] Token issued before secret rotation is rejected
- [ ] `req.user.isOAuthClient` is `true`
- [ ] `req.user.oauthClientId` is set
- [ ] Permission intersection applied (user perms AND client restrictions)
- [ ] Existing `oauth_client_credentials` flow still works unchanged
- [ ] Existing user token flows (local, oidc, ldap, ntlm) still work unchanged

### Implementation Notes for Junior Developers

- Follow the exact pattern of the existing `oauth_client_credentials` handler in `jwtAuth.js` (lines ~80-163).
- The key difference: authorization_code tokens have a **user** identity (`sub` = user ID), while client_credentials tokens have a **machine** identity (`sub` = client ID).
- For user validation, follow the pattern used in the `local` auth handler (lines ~172-226): load users config, find user by ID, check if active.
- The user might have been authenticated via any auth method (local, OIDC, LDAP, NTLM). The token's `sub` is the user's ID regardless of how they originally authenticated. Try looking up the user in the users store; if not found (e.g., proxy auth users), trust the token claims.

---

## TASK 9: Well-Known / OIDC Discovery Updates

### Scope

Update the OIDC discovery endpoint to accurately reflect the newly implemented capabilities.

### Complexity: S (Small)

### Files to MODIFY

- `server/routes/wellKnown.js`

### Dependencies

- TASK 3 (token endpoint capabilities)
- TASK 7 (UserInfo endpoint exists)

### Deliverables

1. **Updated discovery response** in `/.well-known/openid-configuration`:
   ```javascript
   const discovery = {
     issuer: 'ihub-apps',
     jwks_uri: `${baseUrl}/.well-known/jwks.json`,
     authorization_endpoint: `${baseUrl}/api/oauth/authorize`,  // CHANGED
     token_endpoint: `${baseUrl}/api/oauth/token`,
     userinfo_endpoint: `${baseUrl}/api/oauth/userinfo`,        // NEW
     revocation_endpoint: `${baseUrl}/api/oauth/revoke`,        // NEW
     introspection_endpoint: `${baseUrl}/api/oauth/introspect`, // NEW
     response_types_supported: ['code'],                         // CHANGED
     grant_types_supported: ['client_credentials', 'authorization_code', 'refresh_token'],
     subject_types_supported: ['public'],
     id_token_signing_alg_values_supported: [algorithm],
     token_endpoint_auth_methods_supported: ['client_secret_post', 'client_secret_basic', 'none'],
     scopes_supported: ['openid', 'profile', 'email'],
     claims_supported: ['sub', 'name', 'email', 'groups', 'iss', 'aud', 'exp', 'iat', 'nonce'],
     code_challenge_methods_supported: ['S256']                  // NEW
   };
   ```

### Acceptance Criteria

- [ ] `authorization_endpoint` points to `/api/oauth/authorize` (not `/api/auth/oidc`)
- [ ] `userinfo_endpoint` is present
- [ ] `revocation_endpoint` is present
- [ ] `introspection_endpoint` is present
- [ ] `code_challenge_methods_supported` includes `S256`
- [ ] `grant_types_supported` includes `authorization_code` and `refresh_token`
- [ ] `response_types_supported` is `["code"]` (removed `"token"`)
- [ ] `claims_supported` is present
- [ ] All endpoint URLs use correct base URL

---

## TASK 10: Session Middleware for OAuth Authorization Flow

### Scope

Add session middleware scoped to the OAuth authorization endpoints so that the authorize flow can maintain state across the authentication redirect.

### Complexity: S (Small)

### Files to MODIFY

- `server/middleware/setup.js` -- Add OAuth session middleware in `setupSessionMiddleware()`

### Dependencies

- TASK 5 (authorize endpoint needs sessions for login redirect round-trip)

### Deliverables

1. **OAuth session middleware** added to `setupSessionMiddleware()`:
   ```javascript
   // OAuth authorization flow sessions
   logger.info('Enabling session middleware for OAuth authorization flow', {
     component: 'Middleware'
   });
   const oauthMaxAge = 15 * 60 * 1000; // 15 minutes
   app.use(
     '/api/oauth',
     session({
       store: new MemoryStore({ checkPeriod: oauthMaxAge }),
       secret: sessionSecret,
       resave: false,
       saveUninitialized: true,
       name: 'oauth.session',
       cookie: {
         secure: config.USE_HTTPS === 'true',
         httpOnly: true,
         maxAge: oauthMaxAge,
         sameSite: 'lax',
         path: '/api/oauth'
       }
     })
   );
   ```

### Acceptance Criteria

- [ ] Session middleware active on `/api/oauth/*` paths
- [ ] Session persists across authorize -> login -> authorize redirect cycle
- [ ] Session cookie scoped to `/api/oauth` path
- [ ] Session expires after 15 minutes
- [ ] Does not interfere with existing OIDC sessions (different cookie name)
- [ ] Does not interfere with existing integration sessions (different cookie name)
- [ ] Uses memorystore for automatic cleanup

### Implementation Notes for Junior Developers

- Add this block in `setupSessionMiddleware()` in `server/middleware/setup.js`, right after the integration session block (around line 245).
- Follow the exact pattern of the existing OIDC and integration session blocks.
- The cookie name `oauth.session` must be unique (different from `oidc.session` and `integration.session`).
- **Alternative approach:** If TASK 5 implements the stateless consent form (all OAuth params in hidden fields), this session middleware may only be needed for the login redirect round-trip. In that case, consider whether the OAuth params can be passed through the login redirect URL instead.

---

## TASK 11: Example Client Application

### Scope

Create a standalone Node.js/Express example application demonstrating the complete OAuth 2.0 Authorization Code Flow with PKCE.

### Complexity: L (Large)

### Files to CREATE

- `examples/oauth-client/package.json`
- `examples/oauth-client/server.js`
- `examples/oauth-client/.env.example`
- `examples/oauth-client/public/index.html`
- `examples/oauth-client/public/callback.html`
- `examples/oauth-client/public/dashboard.html`
- `examples/oauth-client/public/style.css`
- `examples/oauth-client/README.md`

### Dependencies

- TASK 5 (authorize endpoint)
- TASK 6 (refresh tokens)
- TASK 7 (UserInfo endpoint)

### Deliverables

1. **Express server** (`server.js`) with routes:
   - `GET /` -- Landing page
   - `GET /login` -- Generates PKCE, redirects to iHub authorize
   - `GET /callback` -- Receives code, exchanges for tokens
   - `GET /dashboard` -- Shows user info, tokens
   - `POST /refresh` -- Refreshes access token
   - `POST /logout` -- Revokes tokens, clears session

2. **Environment config** (`.env.example`)
3. **HTML pages** with clean styling
4. **README** with setup instructions

### Acceptance Criteria

- [ ] `npm install && npm start` runs successfully
- [ ] Login redirects to iHub authorize endpoint
- [ ] Callback exchanges code for tokens
- [ ] Dashboard shows user profile from UserInfo
- [ ] Token refresh works
- [ ] Logout revokes tokens
- [ ] Works in both confidential and public modes
- [ ] README enables setup in less than 10 minutes

---

## TASK 12: End-to-End Testing + Security Verification

### Scope

Comprehensive test suite for the full authorization code flow, security edge cases, backward compatibility, and OIDC interoperability.

### Complexity: XL (Extra Large)

### Files to CREATE

- `server/__tests__/oauth/authorizationCodeFlow.test.js`
- `server/__tests__/oauth/pkce.test.js`
- `server/__tests__/oauth/refreshTokens.test.js`
- `server/__tests__/oauth/consentManagement.test.js`
- `server/__tests__/oauth/idToken.test.js`
- `server/__tests__/oauth/tokenRevocation.test.js`
- `server/__tests__/oauth/backwardCompatibility.test.js`
- `server/__tests__/oauth/securityEdgeCases.test.js`

### Dependencies

- All previous tasks

### Test Coverage Areas

1. PKCE: verifier/challenge generation, S256 verification, format validation, `plain` rejection
2. Full flow: authorize -> login -> consent -> code -> token (happy path)
3. Refresh tokens: issuance, refresh, rotation, expiry, revocation
4. Consent: grant, lookup, expiry, revocation, scope comparison
5. id_token: claims, nonce, audience, signature verification via JWKS
6. Revocation: refresh token revoke, 200 OK always, client auth
7. Backward compat: client_credentials still works, static API keys still work
8. Security: code replay, PKCE downgrade, redirect URI manipulation, CSRF, expired tokens

### Acceptance Criteria

- [ ] All tests pass
- [ ] Backward compatibility confirmed
- [ ] Security edge cases handled
- [ ] Test coverage > 80% for new code

---

## Risk Assessment

### High Risk

| Risk | Impact | Mitigation |
|------|--------|------------|
| TASK 5 complexity | Could delay project | Implement stateless consent first, break into sub-tasks |
| Session conflicts | Could break existing auth | Scoped sessions with unique cookie names |
| Token signing mismatch | id_tokens unverifiable | Enforce RS256 for id_tokens, test with external OIDC library |

### Medium Risk

| Risk | Impact | Mitigation |
|------|--------|------------|
| Admin UI merge conflicts | UI changes conflict | Complete UI task early |
| Refresh token perf | bcrypt O(n) per client | Add clientId index if needed |
| Migration side effects | Could affect existing clients | Migration only adds fields, never modifies |

### Low Risk

| Risk | Impact | Mitigation |
|------|--------|------------|
| Example app delay | Demo delayed, not functionality | Can deliver after core flow |
| CORS issues | Browser blocks redirects | Authorization flow uses browser redirects, not XHR |

---

## Key Architecture Decisions

1. **Stateless consent form:** All OAuth params embedded as hidden form fields with CSRF protection. No session dependency for consent.
2. **id_token uses platform algorithm:** RS256 by default via `tokenService.js`. Existing client_credentials remains HS256.
3. **Permission intersection in middleware:** JWT auth middleware computes intersection of user + client permissions.
4. **No template engine:** Consent screen is a JS function returning HTML string.
5. **File-based refresh token storage:** Following existing patterns (`oauth-clients.json`, `users.json`).

---

*-- End of Document --*
